diff --git a/.vscode/settings.json b/.vscode/settings.json
new file mode 100644
index 0000000..59f9afc
--- /dev/null
+++ b/.vscode/settings.json
@@ -0,0 +1,12 @@
+{
+    "files.associations": {
+        "user.h": "c",
+        "types.h": "c",
+        "stat.h": "c",
+        "defs.h": "c",
+        "proc.h": "c",
+        "pstat.h": "c",
+        "spinlock.h": "c",
+        "rand.h": "c"
+    }
+}
\ No newline at end of file
diff --git a/Makefile b/Makefile
index f8c820e..6bfee12 100644
--- a/Makefile
+++ b/Makefile
@@ -28,7 +28,8 @@ OBJS = \
   $K/sysfile.o \
   $K/kernelvec.o \
   $K/plic.o \
-  $K/virtio_disk.o
+  $K/virtio_disk.o \
+  $K/stat.o
 
 # riscv64-unknown-elf- or riscv64-linux-gnu-
 # perhaps in /opt/riscv/bin
@@ -139,6 +140,9 @@ UPROGS=\
 	$U/_grind\
 	$U/_wc\
 	$U/_zombie\
+	$U/_history\
+	$U/_dummyproc\
+	$U/_testprocinfo\
 
 fs.img: mkfs/mkfs README $(UPROGS)
 	mkfs/mkfs fs.img README $(UPROGS)
@@ -160,7 +164,7 @@ QEMUGDB = $(shell if $(QEMU) -help | grep -q '^-gdb'; \
 	then echo "-gdb tcp::$(GDBPORT)"; \
 	else echo "-s -p $(GDBPORT)"; fi)
 ifndef CPUS
-CPUS := 3
+CPUS := 1
 endif
 
 QEMUOPTS = -machine virt -bios none -kernel $K/kernel -m 128M -smp $(CPUS) -nographic
diff --git a/kernel/defs.h b/kernel/defs.h
index d1b6bb9..87aa92d 100644
--- a/kernel/defs.h
+++ b/kernel/defs.h
@@ -8,7 +8,8 @@ struct spinlock;
 struct sleeplock;
 struct stat;
 struct superblock;
-
+extern struct spinlock boost_lock;
+extern int ticks_since_boost;
 // bio.c
 void            binit(void);
 struct buf*     bread(uint, uint);
@@ -106,6 +107,9 @@ void            yield(void);
 int             either_copyout(int user_dst, uint64 dst, void *src, uint64 len);
 int             either_copyin(void *dst, int user_src, uint64 src, uint64 len);
 void            procdump(void);
+int             history(int);
+ uint64
+rand(void);
 
 // swtch.S
 void            swtch(struct context*, struct context*);
diff --git a/kernel/main.c b/kernel/main.c
index f0d3171..ebdeb17 100644
--- a/kernel/main.c
+++ b/kernel/main.c
@@ -3,13 +3,15 @@
 #include "memlayout.h"
 #include "riscv.h"
 #include "defs.h"
-
+#include "stat.h"
+// #include "rand.h"
 volatile static int started = 0;
 
 // start() jumps here in supervisor mode on all CPUs.
 void
 main()
 {
+  
   if(cpuid() == 0){
     consoleinit();
     printfinit();
@@ -20,6 +22,7 @@ main()
     kvminit();       // create kernel page table
     kvminithart();   // turn on paging
     procinit();      // process table
+    // randinit(); // random number generator
     trapinit();      // trap vectors
     trapinithart();  // install kernel trap vector
     plicinit();      // set up interrupt controller
@@ -28,6 +31,9 @@ main()
     iinit();         // inode table
     fileinit();      // file table
     virtio_disk_init(); // emulated hard disk
+    init_syscall_stats();
+    
+
     userinit();      // first user process
     __sync_synchronize();
     started = 1;
diff --git a/kernel/param.h b/kernel/param.h
index 80ec6d3..308e382 100644
--- a/kernel/param.h
+++ b/kernel/param.h
@@ -13,3 +13,10 @@
 #define MAXPATH      128   // maximum file path name
 #define USERSTACK    1     // user stack pages
 
+#define TIME_LIMIT_1 1
+#define TIME_LIMIT_2 2
+#define BOOST_INTERVAL 64
+#define DEFAULT_TICKET_COUNT 10
+
+
+#define PRINT_SCHEDULING 0
\ No newline at end of file
diff --git a/kernel/proc.c b/kernel/proc.c
index 130d9ce..042a473 100644
--- a/kernel/proc.c
+++ b/kernel/proc.c
@@ -5,10 +5,17 @@
 #include "spinlock.h"
 #include "proc.h"
 #include "defs.h"
+#include "stat.h"
+// #include "rand.h"
+#include "pstat.h"
+
 
-struct cpu cpus[NCPU];
 
+struct cpu cpus[NCPU];
 struct proc proc[NPROC];
+int ticks_since_boost = 0;
+struct spinlock boost_lock;
+
 
 struct proc *initproc;
 
@@ -43,12 +50,31 @@ proc_mapstacks(pagetable_t kpgtbl)
   }
 }
 
+
+
+
+
+
+
+static uint64 rand_seed = 0x123456789ABCDEF0ULL; // Deterministic seed
+
+// Generate a pseudo-random number
+ uint64
+rand(void)
+{
+  rand_seed = rand_seed * 6364136223846793005ULL + 1442695040888963407ULL;
+  return rand_seed >> 33;
+}
+
+
+
+
 // initialize the proc table.
 void
 procinit(void)
 {
   struct proc *p;
-  
+  initlock(&boost_lock, "boost");
   initlock(&pid_lock, "nextpid");
   initlock(&wait_lock, "wait_lock");
   for(p = proc; p < &proc[NPROC]; p++) {
@@ -123,6 +149,11 @@ allocproc(void)
 
 found:
   p->pid = allocpid();
+  p->queue = 1;                    // Start in queue 1 (lottery)
+  p->original_tickets = DEFAULT_TICKET_COUNT;
+  p->current_tickets = DEFAULT_TICKET_COUNT;
+  p->time_slices_total = 0;
+  p->time_slices_current = 0;
   p->state = USED;
 
   // Allocate a trapframe page.
@@ -295,6 +326,11 @@ fork(void)
     return -1;
   }
   np->sz = p->sz;
+  np->original_tickets = p->original_tickets;
+  np->current_tickets = p->current_tickets;
+  np->queue = 1; // New process starts in queue 1
+  np->time_slices_total = 0;
+  np->time_slices_current = 0;
 
   // copy saved user registers.
   *(np->trapframe) = *(p->trapframe);
@@ -446,40 +482,112 @@ scheduler(void)
 {
   struct proc *p;
   struct cpu *c = mycpu();
-
+  
   c->proc = 0;
   for(;;){
-    // The most recent process to run may have had interrupts
-    // turned off; enable them to avoid a deadlock if all
-    // processes are waiting.
+    // Avoid deadlock by ensuring that devices can interrupt.
     intr_on();
 
-    int found = 0;
+    // Priority boosting
+    acquire(&boost_lock);
+    if(ticks_since_boost >= BOOST_INTERVAL) {
+      for(p = proc; p < &proc[NPROC]; p++) {
+        acquire(&p->lock);
+        if(p->state == RUNNABLE) {
+          p->queue = 1;
+          p->current_tickets = p->original_tickets;
+          p->time_slices_current = 0;
+          // if(PRINT_SCHEDULING)
+          //   printf("Boosting PID %d to queue 1\n", p->pid);
+        }
+        release(&p->lock);
+      }
+      ticks_since_boost = 0;
+    }
+    release(&boost_lock);
+
+    // Check queue 1 (lottery scheduling)
+    int total_tickets = 0;
     for(p = proc; p < &proc[NPROC]; p++) {
       acquire(&p->lock);
-      if(p->state == RUNNABLE) {
-        // Switch to chosen process.  It is the process's job
-        // to release its lock and then reacquire it
-        // before jumping back to us.
-        p->state = RUNNING;
+      if(p->state == RUNNABLE && p->queue == 1) {
+        total_tickets += p->current_tickets;
+      }
+      release(&p->lock);
+    }
+
+    if(total_tickets > 0) {
+      uint64 ticket = rand() % total_tickets;
+      int current_ticket = 0;
+      for(p = proc; p < &proc[NPROC]; p++) {
+        acquire(&p->lock);
+        if(p->state == RUNNABLE && p->queue == 1) {
+          current_ticket += p->current_tickets;
+          if(ticket < current_ticket) {
+            // Schedule this process
+            p->current_tickets--;
+            p->time_slices_current++;
+            p->time_slices_total++;
+            c->proc = p;
+            // if(PRINT_SCHEDULING)
+              // printf("Scheduling PID %d (queue 1, tickets %d)\n", p->pid, p->current_tickets);
+            swtch(&c->context, &p->context);
+            c->proc = 0;
+            // Check if process should move to queue 2
+            if(p->time_slices_current >= TIME_LIMIT_1 && p->state == RUNNABLE) {
+              p->queue = 2;
+              p->time_slices_current = 0;
+              // if(PRINT_SCHEDULING)
+                // printf("Moving PID %d to queue 2\n", p->pid);
+            }
+            // Reset tickets if all are used
+            if(p->current_tickets == 0 && p->state == RUNNABLE) {
+              p->current_tickets = p->original_tickets;
+              // if(PRINT_SCHEDULING)
+                // printf("Resetting tickets for PID %d\n", p->pid);
+            }
+            release(&p->lock);
+            goto next;
+          }
+        }
+        release(&p->lock);
+      }
+    }
+
+    // Check queue 2 (Round-Robin)
+    for(p = proc; p < &proc[NPROC]; p++) {
+      acquire(&p->lock);
+      if(p->state == RUNNABLE && p->queue == 2) {
+        p->time_slices_current++;
+        p->time_slices_total++;
         c->proc = p;
+        // if(PRINT_SCHEDULING)
+          // printf("Scheduling PID %d (queue 2)\n", p->pid);
         swtch(&c->context, &p->context);
-
-        // Process is done running for now.
-        // It should have changed its p->state before coming back.
         c->proc = 0;
-        found = 1;
+        // Check if process should move to queue 1 (voluntary yield)
+        if(p->state == RUNNABLE && p->time_slices_current < TIME_LIMIT_2) {
+          p->queue = 1;
+          p->time_slices_current = 0;
+          p->current_tickets = p->original_tickets;
+          // if(PRINT_SCHEDULING)
+            // printf("Moving PID %d to queue 1 (yield)\n", p->pid);
+        }
+        // Check if process should stay in queue 2
+        if(p->time_slices_current >= TIME_LIMIT_2 && p->state == RUNNABLE) {
+          p->time_slices_current = 0;
+          // if(PRINT_SCHEDULING)
+            // printf("Keeping PID %d in queue 2\n", p->pid);
+        }
+        release(&p->lock);
+        goto next;
       }
       release(&p->lock);
     }
-    if(found == 0) {
-      // nothing to run; stop running on this core until an interrupt.
-      intr_on();
-      asm volatile("wfi");
-    }
+next:
+    ;
   }
 }
-
 // Switch to scheduler.  Must hold only p->lock
 // and have changed proc->state. Saves and restores
 // intena because intena is a property of this
@@ -693,3 +801,20 @@ procdump(void)
     printf("\n");
   }
 }
+
+
+
+extern struct syscall_stat stats[MAX_SYSCALLS];
+
+int history(int n){
+  struct syscall_stat stat=stats[n];
+  uint64 stat_addr;
+  argaddr(1, &stat_addr);
+  if (copyout(myproc()->pagetable, stat_addr, (char *)&stat, sizeof(stat)) < 0) {
+    printf("sys_history: copyout failed\n");
+    return -1;
+  }
+
+
+  return n;
+}
diff --git a/kernel/proc.h b/kernel/proc.h
index d021857..766c2ac 100644
--- a/kernel/proc.h
+++ b/kernel/proc.h
@@ -1,4 +1,9 @@
+
+// int ticks_since_boost=0;
+// static int ticks_since_boost = 0;
+// static struct spinlock boost_lock;
 // Saved registers for kernel context switches.
+
 struct context {
   uint64 ra;
   uint64 sp;
@@ -27,7 +32,6 @@ struct cpu {
 };
 
 extern struct cpu cpus[NCPU];
-
 // per-process data for the trap handling code in trampoline.S.
 // sits in a page by itself just under the trampoline page in the
 // user page table. not specially mapped in the kernel page table.
@@ -104,4 +108,13 @@ struct proc {
   struct file *ofile[NOFILE];  // Open files
   struct inode *cwd;           // Current directory
   char name[16];               // Process name (debugging)
+
+
+
+  // MLFQ scheduling fields
+  int queue;                   // Current queue (1 for lottery, 2 for Round-Robin)
+  int original_tickets;        // Original ticket count
+  int current_tickets;         // Current ticket count
+  int time_slices_total;       // Total time slices consumed
+  int time_slices_current;     // Time slices consumed in current turn
 };
diff --git a/kernel/pstat.h b/kernel/pstat.h
new file mode 100644
index 0000000..0f08e13
--- /dev/null
+++ b/kernel/pstat.h
@@ -0,0 +1,13 @@
+# ifndef _PSTAT_H_
+# define _PSTAT_H_
+# include "param.h"
+
+struct pstat {
+int pid [ NPROC ]; // the process ID of each process
+int inuse [ NPROC ]; // whether this slot of the process table is being used (1 or 0)
+int inQ [ NPROC ]; // which queue the process is currently in
+int tickets_original [ NPROC ]; // the number of tickets each process originally had
+int tickets_current [ NPROC ]; // the number of tickets each process currently has
+ int time_slices [ NPROC ]; // the number of time slices each process has been scheduled
+};
+# endif // _PSTAT_H_
\ No newline at end of file
diff --git a/kernel/stat.c b/kernel/stat.c
new file mode 100644
index 0000000..4b93804
--- /dev/null
+++ b/kernel/stat.c
@@ -0,0 +1,38 @@
+#include "kernel/types.h"
+#include "stat.h"
+extern char* safestrcpy(char *dst, const char *src, int n);
+
+struct syscall_stat stats[MAX_SYSCALLS];
+void init_syscall_stats(void)
+{
+
+    for (int i = 0; i < MAX_SYSCALLS; i++)
+    {
+        stats[i].count = 0;
+        stats[i].accum_time = 0;
+        // safestrcpy(stats[i].syscall_name, "", 16); // Initialize with empty string
+    }
+    
+    safestrcpy(stats[1].syscall_name, "fork", 16);
+    safestrcpy(stats[2].syscall_name, "exit", 16);
+    safestrcpy(stats[3].syscall_name, "wait", 16);
+    safestrcpy(stats[4].syscall_name, "pipe", 16);
+    safestrcpy(stats[5].syscall_name, "read", 16);
+    safestrcpy(stats[6].syscall_name, "kill", 16);
+    safestrcpy(stats[7].syscall_name, "exec", 16);
+    safestrcpy(stats[8].syscall_name, "fstat", 16);
+    safestrcpy(stats[9].syscall_name, "chdir", 16);
+    safestrcpy(stats[10].syscall_name, "dup", 16);
+    safestrcpy(stats[11].syscall_name, "getpid", 16);
+    safestrcpy(stats[12].syscall_name, "sbrk", 16);
+    safestrcpy(stats[13].syscall_name, "sleep", 16);
+    safestrcpy(stats[14].syscall_name, "uptime", 16);
+    safestrcpy(stats[15].syscall_name, "open", 16);
+    safestrcpy(stats[16].syscall_name, "write", 16);
+    safestrcpy(stats[17].syscall_name, "mknod", 16);
+    safestrcpy(stats[18].syscall_name, "unlink", 16);
+    safestrcpy(stats[19].syscall_name, "link", 16);
+    safestrcpy(stats[20].syscall_name, "mkdir", 16);
+    safestrcpy(stats[21].syscall_name, "close", 16);
+    safestrcpy(stats[22].syscall_name, "history", 16);
+}
diff --git a/kernel/stat.h b/kernel/stat.h
index 19543af..42e5125 100644
--- a/kernel/stat.h
+++ b/kernel/stat.h
@@ -1,7 +1,7 @@
 #define T_DIR     1   // Directory
 #define T_FILE    2   // File
 #define T_DEVICE  3   // Device
-
+#define MAX_SYSCALLS 23 // Maximum number of syscalls
 struct stat {
   int dev;     // File system's disk device
   uint ino;    // Inode number
@@ -9,3 +9,11 @@ struct stat {
   short nlink; // Number of links to file
   uint64 size; // Size of file in bytes
 };
+
+struct syscall_stat {
+    int count;  // The number of the syscall called
+    int accum_time; // The accumulated time spent in the syscall
+    char syscall_name[16]; // The name of the syscall
+};
+
+void init_syscall_stats(void);
diff --git a/kernel/syscall.c b/kernel/syscall.c
index ed65409..bafe36f 100644
--- a/kernel/syscall.c
+++ b/kernel/syscall.c
@@ -6,6 +6,7 @@
 #include "proc.h"
 #include "syscall.h"
 #include "defs.h"
+#include "stat.h"
 
 // Fetch the uint64 at addr from the current process.
 int
@@ -101,6 +102,9 @@ extern uint64 sys_unlink(void);
 extern uint64 sys_link(void);
 extern uint64 sys_mkdir(void);
 extern uint64 sys_close(void);
+extern uint64 sys_history(void);
+extern uint64 sys_settickets(void);
+extern uint64 sys_getpinfo(void);
 
 // An array mapping syscall numbers from syscall.h
 // to the function that handles the system call.
@@ -126,19 +130,52 @@ static uint64 (*syscalls[])(void) = {
 [SYS_link]    sys_link,
 [SYS_mkdir]   sys_mkdir,
 [SYS_close]   sys_close,
+[SYS_history] sys_history,
+[SYS_settickets] sys_settickets,
+[SYS_getpinfo]   sys_getpinfo,
 };
 
+
+
+
+
+extern struct syscall_stat stats[MAX_SYSCALLS];
+extern uint ticks;
+extern struct spinlock tickslock;
+extern struct spinlock statslock;
+
 void
 syscall(void)
 {
   int num;
   struct proc *p = myproc();
-
+ 
   num = p->trapframe->a7;
   if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
     // Use num to lookup the system call function for num, call it,
-    // and store its return value in p->trapframe->a0
+    // and store its return value in p->trapframe->a0 
+
+    
+    
+    acquire(&tickslock);
+    uint start = ticks;
+    release(&tickslock);
+
+    // Call the function to measure
     p->trapframe->a0 = syscalls[num]();
+    // stats[num].count++;
+
+    acquire(&tickslock);
+    uint end = ticks;
+    release(&tickslock);
+
+    // stats[num].accum_time += (end - start); // Accumulate the time taken by this syscall
+    acquire(&statslock); 
+
+    stats[num].count++;
+    stats[num].accum_time += (end - start);
+    release(&statslock);
+
   } else {
     printf("%d %s: unknown sys call %d\n",
             p->pid, p->name, num);
diff --git a/kernel/syscall.h b/kernel/syscall.h
index bc5f356..d85040f 100644
--- a/kernel/syscall.h
+++ b/kernel/syscall.h
@@ -20,3 +20,6 @@
 #define SYS_link   19
 #define SYS_mkdir  20
 #define SYS_close  21
+#define SYS_history 22
+#define SYS_settickets 23
+#define SYS_getpinfo   24
\ No newline at end of file
diff --git a/kernel/sysproc.c b/kernel/sysproc.c
index 3b4d5bd..c208ce6 100644
--- a/kernel/sysproc.c
+++ b/kernel/sysproc.c
@@ -5,6 +5,7 @@
 #include "memlayout.h"
 #include "spinlock.h"
 #include "proc.h"
+#include "pstat.h"
 
 uint64
 sys_exit(void)
@@ -91,3 +92,81 @@ sys_uptime(void)
   release(&tickslock);
   return xticks;
 }
+
+
+
+uint64
+sys_history(void)
+{
+
+  int n;
+  argint(0, &n);
+
+  if(n<1 || n>22){
+    printf("Invalid syscall number: %d. Valid range is 1 to 22.\n", n);
+    return -1;
+  }
+
+  return history(n);
+  
+ 
+}
+
+
+uint64
+sys_settickets(void)
+{
+  int number;
+  argint(0, &number) ;
+  
+  if(number < 1)
+    number = DEFAULT_TICKET_COUNT;
+  struct proc *p = myproc();
+  acquire(&p->lock);
+  p->original_tickets = number;
+  p->current_tickets = number;
+  release(&p->lock);
+  return 0;
+}
+
+extern struct proc proc[];
+
+uint64
+sys_getpinfo(void)
+{
+  uint64 addr;
+  struct pstat ps;
+  struct proc *p;
+  argaddr(0, &addr);
+    
+  if(addr <= 0)
+    return -1;
+  // Initialize pstat
+  for(int i = 0; i < NPROC; i++) {
+    ps.pid[i] = 0;
+    ps.inuse[i] = 0;
+    ps.inQ[i] = 0;
+    ps.tickets_original[i] = 0;
+    ps.tickets_current[i] = 0;
+    ps.time_slices[i] = 0;
+  }
+  // Fill pstat
+  int idx = 0;
+  for(p = proc; p < &proc[NPROC]; p++) {
+    acquire(&p->lock);
+    if(p->state != UNUSED) {
+      ps.pid[idx] = p->pid;
+      ps.inuse[idx] = 1;
+      ps.inQ[idx] = p->queue;
+      ps.tickets_original[idx] = p->original_tickets;
+      ps.tickets_current[idx] = p->current_tickets;
+      ps.time_slices[idx] = p->time_slices_total;
+      idx++;
+    }
+    release(&p->lock);
+  }
+  // Copy to user space
+  if(copyout(myproc()->pagetable, addr, (char *)&ps, sizeof(ps)) < 0)
+    return -1;
+  return 0;
+}
\ No newline at end of file
diff --git a/kernel/trap.c b/kernel/trap.c
index d454a7d..42c5e5a 100644
--- a/kernel/trap.c
+++ b/kernel/trap.c
@@ -9,6 +9,8 @@
 struct spinlock tickslock;
 uint ticks;
 
+struct spinlock statslock;
+
 extern char trampoline[], uservec[], userret[];
 
 // in kernelvec.S, calls kerneltrap().
@@ -20,6 +22,7 @@ void
 trapinit(void)
 {
   initlock(&tickslock, "time");
+  initlock(&statslock, "stats");
 }
 
 // set up to take exceptions and traps while in the kernel.
@@ -166,7 +169,11 @@ clockintr()
   if(cpuid() == 0){
     acquire(&tickslock);
     ticks++;
-    wakeup(&ticks);
+    // wakeup(&ticks);
+    
+    acquire(&boost_lock);
+    ticks_since_boost++;
+    release(&boost_lock);
     release(&tickslock);
   }
 
diff --git a/newalveeyayy.txt b/newalveeyayy.txt
new file mode 100644
index 0000000..e69de29
diff --git a/user/dummyproc.c b/user/dummyproc.c
new file mode 100644
index 0000000..32e1145
--- /dev/null
+++ b/user/dummyproc.c
@@ -0,0 +1,73 @@
+#include "kernel/types.h"
+#include "kernel/stat.h"
+#include "user/user.h"
+#include "kernel/pstat.h"
+
+int
+main(int argc, char *argv[])
+{
+  int tickets = -1;
+  if(argc > 1) {
+    tickets = atoi(argv[1]);
+  }
+  if(settickets(tickets) < 0) {
+    printf("Error setting tickets\n");
+    // exit(2);
+  }
+  // Fork a child to test inheritance
+  int num_of_iteration =1000000000;
+
+  int child_num=3;
+
+  int pid ;
+
+
+
+  for (int i = 0; i < child_num; i++)
+  {
+      pid = fork();
+      if (pid == 0)
+      {
+          break;
+      }
+  }
+
+if (pid != 0)
+    {
+        int a = 7;
+        for (int i = 0; i < num_of_iteration; i++)
+        {
+            // collatz conjecture
+            if (a % 2 == 1)
+            {
+                a = 3 * a + 1;
+            }
+            else
+            {
+                a /= 2;
+            }
+        }
+    }
+    else
+    {
+        int a = 0;
+        for (int i = 0; i < num_of_iteration; i++)
+        {
+            // collatz conjecture
+            if (a % 2 == 1)
+            {
+                a = 3 * a + 1;
+            }
+            else
+            {
+                a /= 2;
+            }
+            if (i % 100000000 == 0)
+            {
+                sleep(5);
+            }
+        }
+    }
+
+  
+}
\ No newline at end of file
diff --git a/user/history.c b/user/history.c
new file mode 100644
index 0000000..d373ad6
--- /dev/null
+++ b/user/history.c
@@ -0,0 +1,48 @@
+#include "kernel/types.h"
+#include "kernel/stat.h"
+#include "user/user.h"
+
+
+
+
+
+int main(int argc, char *argv[])
+{
+
+    // printf(" history no %s\n", argv[1]);
+    int syscall_num = 0;
+    struct syscall_stat stat= {0, 0, "alvee"};
+
+
+
+    if(argc>1){
+        syscall_num =atoi(argv[1]);
+         int history_fd=history(syscall_num, &stat);
+
+        if (history_fd>0){
+            printf("\n%d: syscall: %s, #: %d, time: %d\n", 
+                history_fd, 
+                stat.syscall_name, 
+                stat.count, 
+                stat.accum_time);
+        }
+    }
+    else if(argc==1){
+       for(int i = 1; i < MAX_SYSCALLS; i++){
+            int history_fd=history(i, &stat);
+            if (history_fd>0){
+                printf("\n%d: syscall: %s, #: %d, time: %d\n", 
+                    history_fd, 
+                    stat.syscall_name, 
+                    stat.count, 
+                    stat.accum_time);
+            }
+        }
+        printf("\n");
+    }
+    else{
+        printf("Invalid arguments. Please provide a syscall number from 1 to %d.\n",MAX_SYSCALLS-1);
+        return -1;
+    }
+    return 0;
+}
\ No newline at end of file
diff --git a/user/testprocinfo.c b/user/testprocinfo.c
new file mode 100644
index 0000000..f8562e1
--- /dev/null
+++ b/user/testprocinfo.c
@@ -0,0 +1,31 @@
+#include "kernel/types.h"
+#include "kernel/stat.h"
+#include "user/user.h"
+#include "kernel/pstat.h"
+
+#define RED_COLOR "\033[31m"
+#define BLUE_COLOR "\033[34m"
+#define RESET_COLOR "\033[0m"
+
+
+int
+main(int argc, char *argv[])
+{
+  struct pstat ps;
+  if(getpinfo(&ps) < 0) {
+    printf("Error getting pinfo\n");
+    exit(1);
+  }
+  
+  printf(RED_COLOR "|  PID  | In Use| In Q  |Original Tickets|Current Tickets| Time Slices  |\n" RESET_COLOR);
+  printf(RED_COLOR "|-------|-------|-------|----------------|---------------|--------------|\n" RESET_COLOR);
+
+  for(int i = 0; i < NPROC; i++) {
+    if(ps.inuse[i]) {
+      printf(BLUE_COLOR "|%d\t| %d\t| %d\t| \t%d\t | \t%d\t | \t%d\t|\n" RESET_COLOR,
+             ps.pid[i], ps.inuse[i], ps.inQ[i],
+             ps.tickets_original[i], ps.tickets_current[i], ps.time_slices[i]);
+    }
+  }
+  exit(0);
+}
\ No newline at end of file
diff --git a/user/user.h b/user/user.h
index f16fe27..8d98fd4 100644
--- a/user/user.h
+++ b/user/user.h
@@ -1,4 +1,6 @@
 struct stat;
+struct syscall_stat;
+struct pstat;
 
 // system calls
 int fork(void);
@@ -22,6 +24,9 @@ int getpid(void);
 char* sbrk(int);
 int sleep(int);
 int uptime(void);
+int history(int,struct syscall_stat*);
+int settickets(int);
+int getpinfo(struct pstat *);
 
 // ulib.c
 int stat(const char*, struct stat*);
diff --git a/user/usys.pl b/user/usys.pl
index 01e426e..11a6776 100755
--- a/user/usys.pl
+++ b/user/usys.pl
@@ -36,3 +36,6 @@ entry("getpid");
 entry("sbrk");
 entry("sleep");
 entry("uptime");
+entry("history");
+entry("settickets");
+entry("getpinfo");
